import greenfoot.*;

public class Knight extends Actor {
    // Properti Gerakan & Fisika
    private int vSpeed = 0;
    private final int GRAVITY = 1;
    private final int JUMP_STRENGTH = -15;
    private final int MOVE_SPEED = 2; // Kecepatan bergerak horizontal
    private final int FEET_Y_OFFSET = 32; // Offset Y untuk posisi "kaki" karakter (setengah tinggi sprite 64/2)

    // Properti Animasi
    private GreenfootImage[] idleFrames;
    private GreenfootImage[] walkFrames;
    private GreenfootImage[] attackFrames;
    private GreenfootImage[] jumpFrames; // Gunakan untuk melompat dan jatuh

    private int idleFrameIndex = 0;
    private int walkFrameIndex = 0;
    private int attackFrameIndex = 0;
    private int jumpFrameIndex = 0; // Untuk animasi lompat

    private int animationTimer = 0;
    private final int ANIMATION_SPEED = 8; // Kecepatan animasi

    private boolean isAttacking = false;
    private int attackCooldown = 0; // Cooldown untuk serangan
    private String direction = "right"; // Arah hadap karakter

    public Knight() {
        // Panggil semua metode untuk memuat aset animasi
        loadIdleAnimation();
        loadWalkAnimation();
        loadAttackAnimation();
        loadJumpAnimation();
        setImage(idleFrames[0]); // Atur gambar awal
    }

    public void act() {
        // Kurangi cooldown serangan setiap act cycle
        if (attackCooldown > 0) {
            attackCooldown--;
        }

        handleInput(); // Tangani semua input dari pemain (gerakan dan lompat)
        applyGravity(); // Terapkan gravitasi pada Knight
        checkPlatformCollision(); // Cek dan koreksi tabrakan vertikal dengan platform
        
        // Gerakan horizontal sudah ditangani di handleInput()
        checkHorizontalCollision(); // Cek tabrakan Knight secara horizontal dengan platform/dinding

        handleEnemyCollision(); // Cek tabrakan dengan musuh
        animate(); // Update animasi Knight
    }

    // === BAGIAN GERAKAN DAN INPUT ===
    private void handleInput() {
        // Jika sedang menyerang, Knight tidak bisa bergerak atau melompat
        if (!isAttacking) {
            boolean movingHorizontally = false;

            if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right")) {
                setLocation(getX() + MOVE_SPEED, getY());
                direction = "right";
                movingHorizontally = true;
            } else if (Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
                setLocation(getX() - MOVE_SPEED, getY());
                direction = "left";
                movingHorizontally = true;
            }

            // Hanya bisa melompat jika di tanah
            if ((Greenfoot.isKeyDown("space") || Greenfoot.isKeyDown("w")) && onGround()) {
                vSpeed = JUMP_STRENGTH;
            }
            
            // Reset index animasi jalan jika tidak bergerak secara horizontal
            if (!movingHorizontally) {
                walkFrameIndex = 0; 
            }
        }

        // Serangan bisa dilakukan kapan saja, asalkan tidak dalam cooldown
        if (Greenfoot.isKeyDown("q") && attackCooldown == 0) {
            attack();
        }
    }

    // --- METODE BARU: MENERAPKAN GRAVITASI ---
    private void applyGravity() {
        // Terapkan gravitasi dan batasi kecepatan jatuh agar tidak menembus lantai terlalu cepat
        vSpeed += GRAVITY;
        if (vSpeed > 10) { // Batasi kecepatan jatuh maksimal
            vSpeed = 10;
        }
        setLocation(getX(), getY() + vSpeed);
    }

    // --- PERBAIKAN: METODE checkPlatformCollision SESUAI PERMINTAAN ---
    private void checkPlatformCollision() {
        // Deteksi platform tepat di bawah kaki karakter menggunakan offset virtual
        Actor platform = getOneObjectAtOffset(0, FEET_Y_OFFSET, Platform.class);

        // Hanya koreksi posisi jika karakter sedang jatuh (vSpeed > 0)
        if (platform != null && vSpeed > 0) {
            // Hentikan kecepatan jatuh
            vSpeed = 0;

            // Ambil posisi Y dari bagian atas platform
            int platformTop = platform.getY() - platform.getImage().getHeight() / 2;

            // Atur posisi karakter sehingga "kaki"-nya (Y + FEET_Y_OFFSET)
            // berada tepat di atas platform.
            setLocation(getX(), platformTop - FEET_Y_OFFSET);
            jumpFrameIndex = 0; // Reset jump animation index saat mendarat
        } 
        // Tambahan: Handle jika melompat dan menabrak platform dari bawah (atap)
        else if (platform != null && vSpeed < 0) {
            vSpeed = 0; // Hentikan lompatan
            int platformBottom = platform.getY() + (platform.getImage().getHeight() / 2);
            setLocation(getX(), platformBottom + (getImage().getHeight() / 2));
        }
    }

    private void checkHorizontalCollision() {
        Actor platform = getOneIntersectingObject(Platform.class);
        if (platform != null) {
            // Jika bergerak ke kanan dan menabrak platform
            // Pastikan Knight berada di kiri dari platform yang ditabrak
            if (direction.equals("right") && getX() < platform.getX()) {
                 int platformLeft = platform.getX() - (platform.getImage().getWidth() / 2);
                 setLocation(platformLeft - (getImage().getWidth() / 2), getY());
            }
            // Jika bergerak ke kiri dan menabrak platform
            // Pastikan Knight berada di kanan dari platform yang ditabrak
            else if (direction.equals("left") && getX() > platform.getX()) {
                 int platformRight = platform.getX() + (platform.getImage().getWidth() / 2);
                 setLocation(platformRight + (getImage().getWidth() / 2), getY());
            }
        }
    }

    private void attack() {
        isAttacking = true;
        attackCooldown = 30; // Jeda sebelum bisa menyerang lagi
        attackFrameIndex = 0; // Mulai animasi serangan dari frame pertama
    }

    // --- PERBAIKAN: METODE onGround SESUAI PERMINTAAN ---
    public boolean onGround() {
        // Cek 1 piksel di bawah posisi "kaki" virtual
        Actor platform = getOneObjectAtOffset(0, FEET_Y_OFFSET + 1, Platform.class);
        return platform != null;
    }

    private void checkAttackHit() {
        // Cek apakah ada musuh dalam jangkauan serangan
        int checkDistance = 40; // Jarak jangkauan serangan dari tengah Knight
        if (direction.equals("left")) {
            checkDistance = -checkDistance; // Arah ke kiri, jadi jaraknya negatif
        }

        Musuh enemy = (Musuh) getOneObjectAtOffset(checkDistance, 0, Musuh.class);
        if (enemy != null) {
            // Tambahkan skor berdasarkan stage saat ini
            // Idealnya, metode addScore() harus ada di superclass World yang umum (misalnya BaseStage)
            if (getWorld() instanceof Stage1_Desa) { ((Stage1_Desa) getWorld()).addScore(15); }
            else if (getWorld() instanceof Stage2_Arena) { ((Stage2_Arena) getWorld()).addScore(15); }
            else if (getWorld() instanceof Stage3_Perbatasan) { ((Stage3_Perbatasan) getWorld()).addScore(15); }

            // Hapus musuh
            getWorld().removeObject(enemy);
        }
    }

    // === BAGIAN INTERAKSI ===
    private void handleEnemyCollision() {
        Musuh enemy = (Musuh) getOneObjectAtOffset(0, 0, Musuh.class);
        if (enemy != null) {
            // Knight menginjak musuh dari atas (bunuh musuh)
            // Toleransi untuk menginjak: Knight harus sedikit di atas musuh
            if (vSpeed > 0 && getY() < enemy.getY() - (enemy.getImage().getHeight() / 2) + 10) { 
                // Tambahkan skor berdasarkan stage
                if (getWorld() instanceof Stage1_Desa) { ((Stage1_Desa) getWorld()).addScore(10); }
                else if (getWorld() instanceof Stage2_Arena) { ((Stage2_Arena) getWorld()).addScore(10); }
                else if (getWorld() instanceof Stage3_Perbatasan) { ((Stage3_Perbatasan) getWorld()).addScore(10); }
                
                getWorld().removeObject(enemy); // Hapus musuh
                vSpeed = -8; // Knight terpental sedikit ke atas setelah menginjak
            } else { // Knight menyentuh musuh dari samping (kalah)
                getWorld().showText("Anda Kalah!", getWorld().getWidth()/2, getWorld().getHeight()/2);
                Greenfoot.delay(60); // Jeda sebentar sebelum restart level

                // Restart level saat ini
                if (getWorld() instanceof Stage1_Desa) { Greenfoot.setWorld(new Stage1_Desa()); }
                else if (getWorld() instanceof Stage2_Arena) { Greenfoot.setWorld(new Stage2_Arena()); }
                else if (getWorld() instanceof Stage3_Perbatasan) { Greenfoot.setWorld(new Stage3_Perbatasan()); }
            }
        }
    }

    // === BAGIAN ANIMASI ===
    private void animate() {
        animationTimer++;
        if (animationTimer < ANIMATION_SPEED) return; // Tunggu timer mencapai ANIMATION_SPEED
        animationTimer = 0; // Reset timer

        GreenfootImage currentFrame = null;

        if (isAttacking) {
            attackFrameIndex++;
            if (attackFrameIndex >= attackFrames.length) {
                isAttacking = false; // Hentikan status menyerang setelah animasi selesai
                attackFrameIndex = 0; // Reset index animasi serangan
                // Biarkan logika di bawah yang menentukan animasi idle/walk selanjutnya
            } else {
                currentFrame = attackFrames[attackFrameIndex];
                if (attackFrameIndex == 3) { // Trigger deteksi hit pada frame tertentu (sesuaikan jika perlu)
                    checkAttackHit();
                }
            }
        } else if (!onGround()) { // Jika tidak di tanah (melompat atau jatuh)
            // Gunakan frame awal untuk lompat naik dan frame akhir untuk jatuh
            if (vSpeed < 0) { // Sedang melompat naik
                currentFrame = jumpFrames[0];
            } else { // Sedang jatuh
                currentFrame = jumpFrames[jumpFrames.length - 1];
            }
            // Jika ingin animasi lompat berjalan penuh (gunakan ini jika jumpFrames adalah urutan animasi penuh):
            // jumpFrameIndex = (jumpFrameIndex + 1) % jumpFrames.length;
            // currentFrame = jumpFrames[jumpFrameIndex];

        } else if (Greenfoot.isKeyDown("d") || Greenfoot.isKeyDown("right") || Greenfoot.isKeyDown("a") || Greenfoot.isKeyDown("left")) {
            // Sedang berjalan (salah satu tombol arah ditekan)
            walkFrameIndex = (walkFrameIndex + 1) % walkFrames.length;
            currentFrame = walkFrames[walkFrameIndex];
        } else {
            // Diam (tidak ada tombol arah yang ditekan dan di tanah)
            idleFrameIndex = (idleFrameIndex + 1) % idleFrames.length;
            currentFrame = idleFrames[idleFrameIndex];
        }

        // Terapkan gambar ke Knight dan cerminkan jika perlu berdasarkan arah
        if (currentFrame != null) {
            // Jangan cerminkan animasi serangan jika memang tidak diperlukan (misalnya, jika sprite sudah ada versi kiri/kanan)
            if (direction.equals("left") && currentFrame != attackFrames[attackFrameIndex]) { 
                GreenfootImage mirroredImage = new GreenfootImage(currentFrame);
                mirroredImage.mirrorHorizontally(); // Cerminkan gambar
                setImage(mirroredImage);
            } else {
                setImage(currentFrame);
            }
        }
    }

    // === BAGIAN LOAD ANIMASI (MEMUAT SPRITESHEET MENJADI ARRAY GAMBAR) ===
    private void loadIdleAnimation() {
        idleFrames = new GreenfootImage[4];
        int frameWidth = 100; // Lebar setiap frame di spritesheet
        int frameHeight = 64; // Tinggi setiap frame di spritesheet
        GreenfootImage spritesheet = new GreenfootImage("Idle_KG_2.png"); // Nama file spritesheet
        for (int i = 0; i < idleFrames.length; i++) {
            idleFrames[i] = new GreenfootImage(frameWidth, frameHeight);
            // Gambar bagian spritesheet ke frame individual
            idleFrames[i].drawImage(spritesheet, -i * frameWidth, 0); 
        }
    }

    private void loadWalkAnimation() {
        int frameCount = 7; // Jumlah frame untuk animasi berjalan
        walkFrames= new GreenfootImage[frameCount];
        int frameWidth = 100;
        int frameHeight = 64;
        GreenfootImage spritesheet = new GreenfootImage("Walking_KG_2.png");
        for (int i = 0; i < walkFrames.length; i++) {
            walkFrames[i] = new GreenfootImage(frameWidth, frameHeight);
            walkFrames[i].drawImage(spritesheet, -i * frameWidth, 0);
        }
    }

    private void loadJumpAnimation() {
        int frameCount = 6; // Jumlah frame untuk animasi lompat
        jumpFrames = new GreenfootImage[frameCount];
        int frameWidth = 100;
        int frameHeight = 64;
        GreenfootImage spritesheet = new GreenfootImage("Jump_KG_2.png");
        for (int i = 0; i < jumpFrames.length; i++) {
            jumpFrames[i] = new GreenfootImage(frameWidth, frameHeight);
            jumpFrames[i].drawImage(spritesheet, -i * frameWidth, 0);
        }
    }

    private void loadAttackAnimation() {
        int frameCount = 6; // Jumlah frame untuk animasi serangan
        attackFrames = new GreenfootImage[frameCount];
        int frameWidth = 100;
        int frameHeight = 64;
        GreenfootImage spritesheet = new GreenfootImage("Attack_KG_1.png");
        for (int i = 0; i < attackFrames.length; i++) {
            attackFrames[i] = new GreenfootImage(frameWidth, frameHeight);
            attackFrames[i].drawImage(spritesheet, -i * frameWidth, 0);
        }
    }
}
